#include "std_include.hpp"
#include "game_settings.hpp"
#include "shared/common/toml_ext.hpp"

#define CATCH_ERR_PRINT	catch (toml::type_error& err) { \
		shared::common::log("GameSettings", std::format("{}", err.what()), shared::common::LOG_TYPE::LOG_TYPE_ERROR, true); }

namespace gta4
{
	std::string get_current_comp_version_string()
	{
		return std::string(std::to_string(COMP_MOD_VERSION_MAJOR) + "." + std::to_string(COMP_MOD_VERSION_MINOR) + "." + std::to_string(COMP_MOD_VERSION_PATCH));
	}

	void game_settings::write_toml()
	{
		const std::string file_path = shared::globals::root_path + "\\rtx_comp\\game_settings.toml";
		std::filesystem::create_directories(std::filesystem::path(file_path).parent_path());

		std::ofstream file;
		file.open(file_path.c_str());

		file << "# This file is autogenerated. Valid modifications of settings are considered and will be written back to the file.\n";
		file << "# Installing a new version of the compatibility mod will restore all settings to their defaults.\n";
		file << "CreatedOnCompVersion = \"" << get_current_comp_version_string() << "\"\n\n";

		const std::uint32_t setting_count = sizeof(var_definitions) / sizeof(variable);
		for (auto s = 0u; s < setting_count; s++)
		{
			auto var = reinterpret_cast<variable*>(reinterpret_cast<char*>(&vars) + s * sizeof(variable));

			const auto desc_lines = shared::utils::split(std::string(var->m_desc), '\n');
			for (const auto& line : desc_lines) {
				file << "# " + line << std::endl;
			}

			file << "# Type: " << var->get_str_type() << " || Default: " << var->get_str_value(true) << std::endl;
			file << var->m_name << " = " << var->get_str_value() << std::endl << std::endl;
		}

		file.close();
	}

	bool game_settings::parse_toml()
	{

#ifndef asd // DEBUG
		std::ifstream file;
		if (shared::utils::open_file_homepath("rtx_comp", "game_settings.toml", file))
		{
			// file exists
			file.close();

			try
			{
				auto config = toml::parse("rtx_comp\\game_settings.toml");

				if (config.contains("CreatedOnCompVersion"))
				{
					std::string created_on_comp_version_str;
					auto& val = config.at("CreatedOnCompVersion");
					if (val.is_string())
					{
						try { created_on_comp_version_str = val.as_string(); }
						CATCH_ERR_PRINT;
					}

					if (!created_on_comp_version_str.empty())
					{
						if (created_on_comp_version_str != get_current_comp_version_string())
						{
							write_toml();
							return true;
						}
					}
				}

				// #
				auto to_vec = [](const toml::value& entry, const var_type type, float* default_vec = nullptr)
					{
						std::vector<float> result;

						const size_t size_for_vec =
							type == var_type_vec2 ? 2u :
							type == var_type_vec3 ? 3u :
							type == var_type_vec4 ? 4u : 0u;

						if (entry.is_array())
						{
							if (entry.as_array().size() == size_for_vec)
							{
								for (const auto& val : entry.as_array())
								{
									if (val.is_floating())
									{
										result.push_back((float)val.as_floating());
										continue;
									}

									TOML_ERROR("[GameSettings] #to_vec", val, "expected float but got value_t of => %d ", val.type());
								}

								return result;
							}

							TOML_ERROR("[GameSettings] #to_vec", entry, "unexpected array size of => %d ", entry.as_array().size());
						}

						TOML_ERROR("[GameSettings] #to_vec", entry, "expected a vector but got value_t => %d ", entry.type());

						switch (type)
						{
						default:
							result = { 0, 0, 0, 0 };
							break;
						case var_type_vec2:
							result = { default_vec[0], default_vec[1] };
							break;
						case var_type_vec3:
							result = { default_vec[0], default_vec[1], default_vec[2] };
							break;
						case var_type_vec4:
							result = { default_vec[0], default_vec[1], default_vec[2], default_vec[3] };
							break;
						}

						return result;
					};

				// ---------------------------------------

			#define ASSIGN(name)																								\
				if (config.contains((#name))) {																					\
					switch (vars.##name.get_type()) {																			\
						case (var_type_boolean):																				\
							vars.##name.set_var(shared::common::toml_ext::to_bool(config.at(#name), vars.##name.get_as<bool>()), true); break;			\
						case (var_type_integer):																				\
							vars.##name.set_var(shared::common::toml_ext::to_int(config.at(#name), vars.##name.get_as<int>()), true); break;				\
						case (var_type_value):																					\
							vars.##name.set_var(shared::common::toml_ext::to_float(config.at(#name), vars.##name.get_as<float>()), true); break;			\
						case (var_type_vec2):																					\
						case (var_type_vec3):																					\
						case (var_type_vec4):																					\
							const auto vec = to_vec(config.at(#name), vars.##name.get_type(), vars.##name.get_as<float*>());	\
							vars.##name.set_vec(vec.data(), true); break;														\
					}																											\
				}

				// remix related settings
				ASSIGN(manual_game_resolution_enabled);
				ASSIGN(manual_game_resolution);
				ASSIGN(load_colormaps_only);
				ASSIGN(remix_override_rtxdi_samplecount);
				
				// culling related settings
				ASSIGN(nocull_dist_near_static);
				ASSIGN(nocull_dist_medium_static);
				ASSIGN(nocull_radius_medium_static);
				ASSIGN(nocull_dist_far_static);
				ASSIGN(nocull_radius_far_static);
				ASSIGN(nocull_height_far_static);
				ASSIGN(nocull_dist_lights);
				ASSIGN(nocull_extended);

				// light translation related settings
				ASSIGN(translate_game_lights);
				ASSIGN(translate_game_lights_ignore_filler_lights);
				ASSIGN(translate_game_light_radius_scalar);
				ASSIGN(translate_game_light_intensity_scalar);
				ASSIGN(translate_game_light_softness_offset);
				ASSIGN(translate_game_light_spotlight_volumetric_radiance_scale);
				ASSIGN(translate_game_light_spherelight_volumetric_radiance_scale);
				ASSIGN(translate_game_light_angle_offset);

				ASSIGN(translate_sunlight_intensity_scalar);
				ASSIGN(translate_sunlight_angular_diameter_degrees);
				ASSIGN(translate_sunlight_volumetric_radiance_base);
				ASSIGN(translate_sunlight_timecycle_fogdensity_volumetric_influence_enabled);
				ASSIGN(translate_sunlight_timecycle_fogdensity_volumetric_influence_scalar);

				ASSIGN(translate_vehicle_headlight_intensity_scalar);
				ASSIGN(translate_vehicle_headlight_radius_scalar);
				ASSIGN(translate_vehicle_rearlight_intensity_scalar);
				ASSIGN(translate_vehicle_rearlight_radius_scalar);
				ASSIGN(translate_vehicle_rearlight_inner_cone_angle_offset);
				ASSIGN(translate_vehicle_rearlight_outer_cone_angle_offset);
				ASSIGN(translate_vehicle_rearlight_direction_offset);

				// emissive related settings
				ASSIGN(vehicle_lights_emissive_scalar);
				ASSIGN(vehicle_lights_dual_render_proxy_texture);
				ASSIGN(render_emissive_surfaces_using_shaders);
				ASSIGN(assign_decal_category_to_emissive_surfaces);
				ASSIGN(emissive_night_surfaces_emissive_scalar);
				ASSIGN(emissive_surfaces_emissive_scalar);
				ASSIGN(emissive_strong_surfaces_emissive_scalar);
				ASSIGN(emissive_generic_scale);
				ASSIGN(phone_emissive_override);
				ASSIGN(phone_emissive_scalar);

				// general rendering related settings
				ASSIGN(vehicle_dirt_enabled);
				ASSIGN(vehicle_dirt_custom_color_enabled);
				ASSIGN(vehicle_dirt_custom_color);

				ASSIGN(vehicle_dirt_expo);
				ASSIGN(vehicle_dirt_roughness_z_normal);
				ASSIGN(vehicle_dirt_roughness_blending);

				ASSIGN(vehicle_livery_enabled);
				ASSIGN(decal_dirt_shader_usage);
				ASSIGN(decal_dirt_shader_scalar);
				ASSIGN(decal_dirt_shader_contrast);
				ASSIGN(fixed_function_trees);
				ASSIGN(tree_foliage_alpha_cutout_value);
				ASSIGN(grass_foliage_alpha_cutout_value);
				ASSIGN(npc_expensive_hair_alpha_testing);
				ASSIGN(npc_expensive_hair_alpha_cutout_value);
				ASSIGN(override_water_texture_hash);
				ASSIGN(gta_rmptfx_litsprite_alpha_scalar);

				// timecycle related settings
				ASSIGN(timecycle_set_on_endscene);
				ASSIGN(timecycle_wetness_enabled);
				ASSIGN(timecycle_wetness_world_scalar);
				ASSIGN(timecycle_wetness_world_offset);
				ASSIGN(timecycle_wetness_world_z_normal);
				ASSIGN(timecycle_wetness_world_blending);
				ASSIGN(timecycle_wetness_world_puddles_enable);
				ASSIGN(timecycle_wetness_world_raindrop_enable);
				ASSIGN(timecycle_wetness_world_raindrop_scalar);

				ASSIGN(timecycle_wetness_ped_raindrop_enable);
				ASSIGN(timecycle_wetness_ped_raindrop_scalar);
				
				ASSIGN(timecycle_wetness_vehicle_scalar);
				ASSIGN(timecycle_wetness_vehicle_z_normal);
				ASSIGN(timecycle_wetness_vehicle_blending);

				ASSIGN(timecycle_wetness_vehicle_raindrop_enable);
				ASSIGN(timecycle_wetness_vehicle_raindrop_scalar);
				
				ASSIGN(timecycle_wetness_vehicle_dirt_intensity_scalar);
				ASSIGN(timecycle_wetness_vehicle_dirt_roughness_scalar);
				ASSIGN(timecycle_wetness_vehicle_dirt_z_normal);
				ASSIGN(timecycle_wetness_vehicle_dirt_blending);

				ASSIGN(timecycle_fogcolor_enabled);
				ASSIGN(timecycle_fogcolor_base_strength);
				ASSIGN(timecycle_fogcolor_influence_scalar);
				ASSIGN(timecycle_fogdensity_enabled);
				ASSIGN(timecycle_fogdensity_influence_scalar);
				ASSIGN(timecycle_skyhorizonheight_enabled);
				ASSIGN(timecycle_skyhorizonheight_scalar);
				ASSIGN(timecycle_skyhorizonheight_low_transmittance_offset);
				ASSIGN(timecycle_skyhorizonheight_high_transmittance_offset);
				ASSIGN(timecycle_skylight_enabled);
				ASSIGN(timecycle_skylight_scalar);
				ASSIGN(timecycle_colorcorrection_enabled);
				ASSIGN(timecycle_colorcorrection_influence);
				ASSIGN(timecycle_colortemp_enabled);
				ASSIGN(timecycle_colortemp_value);
				ASSIGN(timecycle_colortemp_influence);
				ASSIGN(timecycle_desaturation_enabled);
				ASSIGN(timecycle_desaturation_influence);
				ASSIGN(timecycle_fardesaturation_influence);
				ASSIGN(timecycle_gamma_enabled);
				ASSIGN(timecycle_gamma_offset);
				ASSIGN(timecycle_bloom_enabled);
				ASSIGN(timecycle_bloomintensity_scalar);
				ASSIGN(timecycle_bloomthreshold_scalar);


			#undef ASSIGN
			}

			catch (const toml::syntax_error& err)
			{
				shared::common::log("GameSettings", std::format("{}", err.what()), shared::common::LOG_TYPE::LOG_TYPE_ERROR, true);
				shared::common::log("GameSettings", "Not writing defaults! Please check 'game_settings.toml' or remove the file to re-generate it on next startup!", shared::common::LOG_TYPE::LOG_TYPE_ERROR, true);
				return false;
			}
		}
#endif

		// always re-write file
		write_toml();
		return true;
	}

	game_settings::game_settings()
	{
		parse_toml();

		// -----
		m_initialized = true;
		shared::common::log("GameSettings", "Module initialized.", shared::common::LOG_TYPE::LOG_TYPE_DEFAULT, false);
	}
}
