#include "std_include.hpp"
#include "game_settings.hpp"
#include "shared/common/toml_ext.hpp"

namespace gta4
{
	void game_settings::write_toml()
	{
		const std::string file_path = shared::globals::root_path + "\\rtx_comp\\game_settings.toml";
		std::filesystem::create_directories(std::filesystem::path(file_path).parent_path());

		std::ofstream file;
		file.open(file_path.c_str());

		file << "# This file is autogenerated. Valid modifications of settings are considered and will be written back to the file.\n\n";

		const std::uint32_t setting_count = sizeof(var_definitions) / sizeof(variable);
		for (auto s = 0u; s < setting_count; s++)
		{
			auto var = reinterpret_cast<variable*>(reinterpret_cast<char*>(&vars) + s * sizeof(variable));

			file << "# " << var->m_desc << std::endl;
			file << "# Type: " << var->get_str_type() << " || Default: " << var->get_str_value(true) << std::endl;
			file << var->m_name << " = " << var->get_str_value() << std::endl << std::endl;
		}

		file.close();
	}

	bool game_settings::parse_toml()
	{
		std::ifstream file;
		if (shared::utils::open_file_homepath("rtx_comp", "game_settings.toml", file))
		{
			// file exists
			file.close();

			try
			{
				auto config = toml::parse("rtx_comp\\game_settings.toml");

				// #
				auto to_vec = [](const toml::value& entry, const var_type type, float* default_vec = nullptr)
					{
						std::vector<float> result;

						const size_t size_for_vec =
							type == var_type_vec2 ? 2u :
							type == var_type_vec3 ? 3u :
							type == var_type_vec4 ? 4u : 0u;

						if (entry.is_array())
						{
							if (entry.as_array().size() == size_for_vec)
							{
								for (const auto& val : entry.as_array())
								{
									if (val.is_floating())
									{
										result.push_back((float)val.as_floating());
										continue;
									}

									TOML_ERROR("[GameSettings] #to_vec", val, "expected float but got value_t of => %d ", val.type());
								}

								return result;
							}

							TOML_ERROR("[GameSettings] #to_vec", entry, "unexpected array size of => %d ", entry.as_array().size());
						}

						TOML_ERROR("[GameSettings] #to_vec", entry, "expected a vector but got value_t => %d ", entry.type());

						switch (type)
						{
						default:
							result = { 0, 0, 0, 0 };
							break;
						case var_type_vec2:
							result = { default_vec[0], default_vec[1] };
							break;
						case var_type_vec3:
							result = { default_vec[0], default_vec[1], default_vec[2] };
							break;
						case var_type_vec4:
							result = { default_vec[0], default_vec[1], default_vec[2], default_vec[3] };
							break;
						}

						return result;
					};

				// ---------------------------------------

			#define ASSIGN(name)																								\
				if (config.contains((#name))) {																					\
					switch (vars.##name.get_type()) {																			\
						case (var_type_boolean):																				\
							vars.##name.set_var(shared::common::toml_ext::to_bool(config.at(#name), vars.##name.get_as<bool>()), true); break;			\
						case (var_type_integer):																				\
							vars.##name.set_var(shared::common::toml_ext::to_int(config.at(#name), vars.##name.get_as<int>()), true); break;				\
						case (var_type_value):																					\
							vars.##name.set_var(shared::common::toml_ext::to_float(config.at(#name), vars.##name.get_as<float>()), true); break;			\
						case (var_type_vec2):																					\
						case (var_type_vec3):																					\
						case (var_type_vec4):																					\
							const auto vec = to_vec(config.at(#name), vars.##name.get_type(), vars.##name.get_as<float*>());	\
							vars.##name.set_vec(vec.data(), true); break;														\
					}																											\
				}

				ASSIGN(fix_windowed_hud);
				ASSIGN(fix_windowed_hud_resolution);
				ASSIGN(fixed_function_trees);
				ASSIGN(tree_foliage_alpha_cutout_value);
				ASSIGN(grass_foliage_alpha_cutout_value);

				ASSIGN(nocull_dist_near_static);
				ASSIGN(nocull_dist_medium_static);
				ASSIGN(nocull_radius_medium_static);
				ASSIGN(nocull_dist_far_static);
				ASSIGN(nocull_radius_far_static);

				ASSIGN(translate_game_lights);
				ASSIGN(translate_game_light_radius_scalar);
				ASSIGN(translate_game_light_intensity_scalar);
				ASSIGN(translate_game_light_softness_offset);
				ASSIGN(translate_game_light_angle_offset);
				ASSIGN(translate_sunlight_intensity_scalar);

				ASSIGN(vehicle_lights_emissive_scalar);
				ASSIGN(vehicle_lights_dual_render_proxy_texture);

				ASSIGN(game_wetness_scalar);

				ASSIGN(render_emissive_surfaces_using_shaders);
				ASSIGN(assign_decal_category_to_emissive_surfaces);
				ASSIGN(emissive_night_surfaces_emissive_scalar);
				ASSIGN(emissive_surfaces_emissive_scalar);
				ASSIGN(emissive_strong_surfaces_emissive_scalar);

				ASSIGN(decal_dirt_shader_usage);
				ASSIGN(decal_dirt_shader_scalar);
				ASSIGN(decal_dirt_shader_contrast);

				ASSIGN(gta_rmptfx_litsprite_alpha_scalar);

			#undef ASSIGN
			}

			catch (const toml::syntax_error& err)
			{
				shared::common::set_console_color_red(true);
				shared::common::console();
				std::cout << err.what() << "\n";
				std::cout << "[!][GameSettings] Not writing defaults! Please check 'game_settings.toml' or remove the file to re-generate it on next startup!\n";
				shared::common::set_console_color_default();
				return false;
			}
		}

		// always re-write file
		write_toml();
		return true;
	}

	game_settings::game_settings()
	{
		parse_toml();

		// -----
		m_initialized = true;
		std::cout << "[GAME_SETTINGS] loaded\n";
	}
}
